<?php if (!defined('THINK_PATH')) exit(); /*a:0:{}*/ ?>
<h2>一、分类</h2><ul><li>创建型模式(5种):工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li><li>结构型模式(7种):适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li><li>行为型模式(11种):策略模式、魔板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介模式、解析器模式</li><li>并发型模式、线程池模式</li></ul><h2>二、六大原则</h2><ul><li>总原则:开闭原则:对扩展开放、对修改关闭</li></ul><h3>1、单一职责原则:</h3><blockquote>不要存在多于一个导致类变更的原因,也就是说每个类应该实现单一的职责,如若不然,应该把类拆分</blockquote><h3>2、里氏替换原则(LSP):</h3><blockquote>里氏替换原则说,任何基类可以出现的地方,子类一定可以出现.里氏替换原则是继承复用的基石,只有当衍生类可以替换掉基类,软件单位的功能不受到影响时,基类才能被真正复用,而衍生类也能在基类的基础上增加新的行为.里氏替换原则是对"开-闭"原则的补充.实现"开-闭"原则的关键步骤就是抽象化.而基类与子类的继承关系就是抽象化的具体实现,所以里氏替换原则是对实现抽样化的具体步骤的规范.</blockquote><h3>3、依赖转换原则</h3><blockquote>这是开闭原则的基础,具体内容:面向接口编程,依赖于抽象而不依赖于具体.写代码时用到具体类时,不与具体类交互,而与具体类的上层接口交互.</blockquote><h3>4、接口隔离原则</h3><blockquote>这个原则的意思是:每个接口中不存在子类用不到却实现的方法,如果不然,就要将接口拆分.使用多个接口隔离,比如使用单个接口(多个接口方法集合到一个接口)要好.</blockquote><h3>5、迪米特法则(最少知道原则)</h3><blockquote>一个类对自己依赖的类知道的越少越好.也就是说无论被依赖的类多么复杂,都应该将逻辑封装在方法的内部,通过public方法提供给外部.这样当被依赖的类变化时,才能最小的影响该类.</blockquote><h3>6、合成复用原则</h3><blockquote>原则是尽量首先使用合成/聚合的方式,而不是使用继承.</blockquote>